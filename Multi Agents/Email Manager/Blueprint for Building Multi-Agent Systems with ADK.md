# Master Blueprint for Building Multi-Agent Systems with ADK

**Objective for the Gemini CLI Tool:** This document is your master blueprint for building a new, production-grade, multi-agent ADK project. When a user provides a new agent concept, follow the patterns, file structures, and templated code examples herein. Your primary task is to adapt the names, prompts, and logic in the placeholders to fit the user's new concept.

---

## Part 0: Project Conception & Planning

**Goal:** Understand the user's request and plan the agent architecture before writing any code.

**Instructions for Gemini CLI:**

1. **Prompt the user for their agent idea.** (e.g., "What kind of agent would you like to build?", "Describe the problem you want to solve.")
2. From the user's response, **determine the overall goal** of the multi-agent system.
3. **Decompose the goal into logical sub-tasks.** Each sub-task will be handled by a specialist sub-agent.
4. **Define names and purposes** for the root coordinator agent and each specialist sub-agent you have identified.
5. **Confirm the plan with the user** before proceeding (e.g., "Okay, I will build an agent that does X. It will have a coordinator and three specialist agents for A, B, and C. Does that sound right?").
6. **Proceed with the following build instructions,** using the names and purposes you have just defined to fill in all `<placeholder>` values.

---

## Part 1: Initial Environment Setup

**Goal:** Prepare the local machine and Google Cloud for development.

### Task 1: Create the Local Project Directory & Virtual Environment

1. **Create the project directory.** Use the name you defined in the planning phase.
   * Execute: `mkdir <project_name>`
   * Execute: `cd <project_name>`
2. **Create the virtual environment.**
   * Execute: `python3 -m venv .venv`
3. **Activate the virtual environment.**
   * Execute: `source .venv/bin/activate`
   * *(Note: This must be done for every new terminal session.)*

### Task 2: Configure the Google Cloud Environment (One-Time Task)

*(Note: These `gcloud` commands should be run for the first project. Subsequent projects can reuse this configuration.)*

1. **Ensure Google Cloud SDK is installed.**
2. **Authenticate and configure the project.** As the Gemini CLI tool, you will execute the following `gcloud` commands automatically. You must inform the user that they will need to follow any on-screen or browser-based prompts to complete the authentication.
   * Execute: `gcloud auth login`
   * Execute: `gcloud auth application-default login`
   * Execute: `gcloud config set project <YOUR_PROJECT_ID>` (You will need to ask the user for their Project ID).
3. **Enable necessary APIs.**
   * Execute: `gcloud services enable aiplatform.googleapis.com storage.googleapis.com cloudbuild.googleapis.com run.googleapis.com artifactregistry.googleapis.com`
4. **Complete billing, bucket, and permission setup** by following the remaining steps in the previous version of this guide if this is the first time setting up a GCP project for ADK.

---

## Part 2: Building the Agent Project Structure

**Goal:** Create all the necessary files and directories for the new agent.

### Task 3: Create Project Files

**Instruction for Gemini CLI:**
Create the following files by using the `write_file` tool. Populate the content based on the templates below, replacing all placeholders with the values you defined in Part 0.

**`Makefile`**

* **Path:** `<project_name>/Makefile`
* **Content:**
  ```makefile
  # Automates common development tasks
  install:
      pip install -e .[dev]

  dev:
      adk web <project_name>

  lint:
      ruff check . --diff
      mypy .

  deploy-adk:
      # This will be configured later
      echo "Deployment script not configured yet."
  ```

**`pyproject.toml`**

* **Path:** `<project_name>/pyproject.toml`
* **Content Template:**
  ```toml
  [project]
  name = "<project_name>"
  version = "0.1.0"
  description = "[A brief, one-line description of the agent's purpose, generated by Gemini CLI.]"
  dependencies = [
      "google-adk",
      "python-dotenv",
  ]
  requires-python = ">=3.10"

  [project.optional-dependencies]
  dev = [
      "ruff",
      "mypy",
      "pytest",
      "pytest-asyncio",
  ]
  ```

**Root Agent Directory**

* **Instruction:** Create the main package directory for the agent.
* **Execute:** `mkdir -p <project_name>/<project_name>/sub_agents`

**`tools.py` (Recommended)**

* **Instruction:** It is good practice to centralize all custom tools and tool-agents into a single file. Create a `tools.py` file for this purpose.
* **Path:** `<project_name>/<project_name>/tools.py`
* **Content Template:**
  ```python
  # Central repository for all tools and tool-agents.
  from google.adk.agents import Agent
  from google.adk.tools import google_search

  # --- Custom Function Tools ---

  def my_custom_tool(param: str) -> str:
      """A brief description of what this tool does."""
      # Tool logic goes here
      return f"Input was {param}"

  # --- Agent-as-a-Tool Definitions ---

  SearchAgent = Agent(
      name="SearchAgent",
      model="gemini-2.0-flash",
      description="Performs a Google search.",
      tools=[google_search],
  )
  ```

**Coordinator Prompt**

* **Path:** `<project_name>/<project_name>/prompt.py`
* **Content Template:**
  ```python
  # Contains all instruction prompts for the agents.

  COORDINATOR_PROMPT = """
  [Instruction for the root coordinator agent, generated by Gemini CLI.]

  Your primary role is to understand the user's request and delegate the task to the correct specialist sub-agent from your tools.

  - For tasks related to [Function of Specialist 1], delegate to the `<specialist_agent_1_name>`.
  - For tasks related to [Function of Specialist 2], delegate to the `<specialist_agent_2_name>`.
  - ...and so on for all specialist agents.
  """

  SPECIALIST_1_PROMPT = """
  [Instruction for the first specialist agent, generated by Gemini CLI.]
  """

  SPECIALIST_2_PROMPT = """
  [Instruction for the second specialist agent, generated by Gemini CLI.]
  """
  # ...and so on for all specialist agents.
  ```

**Root Coordinator Agent**

* **Path:** `<project_name>/<project_name>/agent.py`
* **Content Template:**
  ```python
  # The Root Coordinator Agent for the <project_name> system.
  from google.adk.agents import Agent
  from google.adk.tools.agent_tool import AgentTool

  from . import prompt
  # Import all specialist agents that you will define.
  from .sub_agents.<specialist_agent_1_name> import <specialist_agent_1_name>
  from .sub_agents.<specialist_agent_2_name> import <specialist_agent_2_name>

  # The root_agent uses the AgentTool model to call specialists.
  root_agent = Agent(
      name="<coordinator_agent_name>",
      model="gemini-2.5-pro", # Or another powerful model for orchestration
      description="[High-level description of the entire agent system, generated by Gemini CLI.]",
      instruction=prompt.COORDINATOR_PROMPT,
      tools=[
          AgentTool(agent=<specialist_agent_1_name>),
          AgentTool(agent=<specialist_agent_2_name>),
          # ... Add all specialist agents here.
      ]
  )
  ```

**Specialist Agents**

* **Instruction for Gemini CLI:** For each specialist agent you planned in Part 0, create a corresponding sub-directory and agent files.
* **Example for `<specialist_agent_1_name>`:**
  1. **Create Directory:** `mkdir <project_name>/<project_name>/sub_agents/<specialist_agent_1_name>`
  2. **Create `__init__.py`:**
     * **Path:** `<project_name>/<project_name>/sub_agents/<specialist_agent_1_name>/__init__.py`
     * **Content:** `from .agent import <specialist_agent_1_name>`
  3. **Create `agent.py`:**
     * **Path:** `<project_name>/<project_name>/sub_agents/<specialist_agent_1_name>/agent.py`
     * **Content Template:**
       ```python
       # A specialist agent for [Function of Specialist 1].
       from google.adk.agents import Agent
       from <project_name> import prompt
       from <project_name>.tools import my_custom_tool # Import tools from the central file

       <specialist_agent_1_name> = Agent(
           name="<specialist_agent_1_name>",
           model="gemini-2.0-flash", # A focused, cost-effective model
           description="[A description of what this specific agent does, generated by Gemini CLI.]",
           instruction=prompt.SPECIALIST_1_PROMPT,
           tools=[my_custom_tool] # Add any custom or built-in tools here.
       )
       ```
* **Repeat the process above for all other specialist agents.**

---

### Advanced Pattern: Agent as a Tool

**Context:** Some LLMs have limitations on the types of tools an agent can use simultaneously. For example, an agent might not be able to have both a built-in `google_search` tool and a custom `FunctionTool` in the same `tools` list.

**Pattern:** To work around this, you can use the powerful "Agent as a Tool" pattern. Instead of giving one agent multiple, different types of tools, you can encapsulate each tool within its own dedicated, single-purpose agent.

**Implementation:**

1. **Create Tool-Agents:** For each tool (e.g., `google_search`, a custom function), define a simple, single-purpose agent within the central `<project_name>/<project_name>/tools.py` file. Its prompt should be simple and direct, guiding the LLM to use its one tool.
2. **Refactor the Orchestrator:** The agent that originally needed multiple tools (the "orchestrator") should import the necessary `AgentTool` from `google.adk.tools.agent_tool` and the tool-agents from `<project_name>.tools`. Its `tools` list will then contain `AgentTool` instances wrapping the imported tool-agents.
3. **Update the Orchestrator's Prompt:** The orchestrator's prompt must be updated to instruct it to delegate tasks to the appropriate tool-agent based on its description.

**Example:**

A `StrategyAgent` needs to both search the web and use a custom function.

* **Before:** `StrategyAgent(tools=[google_search, my_custom_function])` -> This might cause an error.
* **After:**
  * Define a `SearchAgent(tools=[google_search])` in `tools.py`.
  * Define a `CustomFunctionAgent(tools=[my_custom_function])` in `tools.py`.
  * Refactor the `StrategyAgent` to be `StrategyAgent(tools=[AgentTool(agent=SearchAgent), AgentTool(agent=CustomFunctionAgent)])`.

This creates a more modular and robust system that can bypass model-specific tool limitations.

---

**`.env.example`**

* **Path:** `<project_name>/.env.example`
* **Content:**
  ```
  # GCP Configuration
  GOOGLE_CLOUD_PROJECT="your-gcp-project-id"
  GOOGLE_CLOUD_LOCATION="us-central1"
  GOOGLE_CLOUD_STAGING_BUCKET="your-gcp-staging-bucket-name"

  # Set to true when deploying to Vertex AI
  GOOGLE_GENAI_USE_VERTEXAI="True"

  # Gemini API Key (for local development if not using Vertex)
  # GOOGLE_API_KEY="your-gemini-api-key"
  ```

### Task 4: Install Dependencies and Configure Environment

1. **Install dependencies.**
   * Execute: `make install`
2. **Set up the `.env` file.**
   * Execute: `cp .env.example .env`
   * **Instruction for Gemini CLI:** Inform the user that they must now manually edit the `.env` file to add their specific GCP and API key details.

---

## Part 3: Local Testing and Deployment

### Task 5: Local Development & Testing

* **Instruction for Gemini CLI:** Once the project is built, you can run the local development server using `make dev`.
* **Inform the user** that the agent is running and provide the local URL (e.g., `http://localhost:8000`).

---

**Note for Manual Server Start:** If you prefer to run the development server manually in a separate terminal, follow these steps from the project's parent directory:

1. Navigate to the project root directory:
   ```bash
   cd <project_name>
   ```
2. Activate the virtual environment:
   ```bash
   source .venv/bin/activate
   ```
3. Run the ADK web server:
   ```bash
   adk web <project_name>
   ```

---

### Task 6: Deployment to Production

* **Instruction for Gemini CLI:** To deploy the agent, you would first need to create a full-featured deployment script (`deploy.py`) and configure the `Makefile`. The example `deploy.py` from the previous version of this document can be used as a template. Once that is in place, deployment can be run via `make deploy-adk`.
